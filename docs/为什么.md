@page why 为什么

## 为什么使用 SDL2 而不是 SDL3

本项目立项在 2024 年 11 月，当时 SDL3 处于预览阶段，网上能搜到的教程多是 SDL2 的。

SDL3 正式发布在 2025 年 1 月：
https://github.com/libsdl-org/SDL/releases

若要迁移 SDL2 到 SDL3，官方提供了迁移指南：
https://github.com/libsdl-org/SDL/blob/main/docs/README-migration.md

## 为什么用 uint64_t 记录游戏的运行时间

SDL2 提供的 `SDL_GetTicks()` 函数能返回自 SDL 库初始化以来经过的毫秒数，不过这个时间戳是 `Uint32` 类型。
用 32 位无符号整型能存储的毫秒级时间范围大概是 49 天，超过 49 天后时间戳会重新从 0 开始计数。

为了避免溢出问题，SDL2 推荐使用 `SDL_GetTicks64()` 来获取时间，该函数返回的时间戳是 `Uint64` 类型，
用 64 位无符号整型能存储的毫秒级时间范围大概是四百亿年，完全不用担心溢出问题。
到了 SDL3 时，`SDL_GetTicks()` 函数已被改成返回 `Uint64` 类型的时间戳。

我当然知道，用该框架做出来的游戏根本不可能运行 49 天这么久，但采用 `Uint64` 类型的时间戳从长远来看更稳妥。
而 SDL 的 `Uint64` 类型对应 C 标准库 `stdint.h` 中的 `uint64_t` 类型，
所以 k_game 使用 `uint64_t` 类型记录游戏的运行时间，提供的接口也是用 `uint64_t` 类型。

## 为什么用 int 类型记录两个游戏帧的间隔时间

k_game 使用 64 位无符号整型 `uint64_t` 类型记录游戏的运行时间，但记录帧间隔并没有一致采用 `uint64_t` 类型，
而是用常见的 `int` 类型。

首先，`int` 类型通常有 32 位。此处 **并不需要严格规定整型的宽度** 为 64 位或是 32 位，
哪怕是游戏卡到 1 秒 1 帧，帧间隔还只是 1000 毫秒而已，`int` 类型完全够用。

其次，两帧间的时间差常涉及各种计算，且多是浮点数和整数的混合运算， **不适合使用无符号的整型** 。

你应该知道，不同类型的数参与混合运算时，较小的类型被提升（隐式类型转换）到较大的类型，比如：
 - 有符号整数和无符号整数混合运算时，有符号整数会被提升为无符号整型
 - 整数和浮点数混合运算时，整数会被类型提升为浮点型
 - ...

如果无符号整数、有符号整数与浮点数混合运算，很可能因为类型提升，计算结果很不符合直觉。例如下述代码：
```C
// 我当前平台的数据类型规格为：
// 无符号整型 unsigned int 占 32 位，能表示的整数范围为 0 ~ 4294967295
// 有符号整型 int 占 32 位，能表示的整数范围为 -2147483648 ~ 2147483647
// 单精度浮点型 float 占 32 位，其中尾数部分 23 位，指数部分 8 位，符号位 1 位
unsigned int u =  1;
int          i = -2;
float        f =  1.0f;
printf("%.2f", (u + i) * f); // 你能预测将打印输出什么结果吗？
```

最符合直觉的输出结果应该是 `-1.00`，因为 (1 - 2) * 1 = -1。但我得到的输出结果是 `4294967296.00`。

我认为一种合理的解释是：
- 先计算加法，是有符号整数和无符号整数混合运算，有符号整数 -2 被提升为无符号整型，
  提升结果是 4294967294，所以加法的计算为无符号整数 4294967295。
- 再计算乘法，是整数和浮点数混合运算，先类型提升整数 4294967295 被为浮点型再相乘。
  而单精度浮点型尾数部分只有 23 位（有效数字只有 7 位左右），所以输出结果是 4294967296.00。

总之，我认为最好是不要让无符号整数参与运算。所以我选择用最常见的有符号整数类型 `int` 来记录帧间隔时间。
