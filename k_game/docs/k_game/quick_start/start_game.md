# 启动游戏

## 头文件包含

k_game 的绝大部分 API 都集中声明在 `k_game.h` 头文件中。
直接包含此头文件，即可全量引入这些API，这种方式最为简单便捷。

而从 `k_game.h` 中的内容可以看出，该头文件仅仅是聚合了 k_game 中各个子模块的头文件。
你可以仿照 `k_game.h` 中引入其他头文件的路径，来自行选择按需引入。
例如，若只想引入 k_game 中部分结构体的前向声明，则可以包含 `k_game/core/k_game_fwd.h`

> 全量引入意味着编译器会处理所有模块的头文件，包括你当前项目用不到的部分。随着项目规模扩大，这会显著拖慢编译速度。
> 但是 k_game 只是一个小框架，只能应付开发一些小项目。在这种体量下，全量引入对编译速度的影响也微乎其微。
> 所以你不必过多纠结，直接包含 `k_game.h` 即可。

## 入口函数

本框架中，游戏的入口函数为 `k_game_run()`，示例代码如下：

```C
/* 此代码不是完整的示例代码，不能直接运行 */

#include "k_game.h"

static int on_game_start(void);

int main(void) {
    
    /* 编写游戏相关的配置，K_GAME_CONFIG_INIT 为默认值 */
    struct k_game_config config = K_GAME_CONFIG_INIT;
    config.window_w = ...; /* 游戏窗口的宽高 */
    config.window_h = ...;
    config.window_title = "my game"; /* 游戏窗口的标题 */
    config.on_start = on_game_start; /* 必须指定游戏初始化的回调 */

    return k_game_run(&config); /* 启动游戏 */
}

/* 游戏初始化时执行的回调 */
static int on_game_start(void) {
    ... /* 在此处加载资源（图片、音频等）、创建房间、注册组件类型 */
    
    return 0; /* 返回 0 表示初始化成功，非 0 表示失败 */
}
```

`k_game_config` 是启动游戏所需的配置参数。因为配置项比较多，所以 k_game 将这些参数打包成一个结构体，
并提供了一个默认值 `K_GAME_CONFIG_INIT`，你只需要填写你关心的那几项配置即可。

> 若 API 的参数太多，k_game 都会将入参打包成一个结构体，并定义一个默认值（通常是一个以 `_INIT` 为后缀的宏）。
> 这是 C 语言中一种经典的 API 向后兼容设计方式。若以后要为 API 新增参数，只需在结构体中新增字段，同时更新默认值宏，旧代码无需改动。
> 同时，该设计也简化了 API 的使用难度，因为调用者只需要填写自己关心的参数，而其他参数可以使用默认值。

你必须指定游戏的初始化回调 `config.on_start`，否则游戏无法启动。
该回调返回 0 表示初始化成功，返回非 0 表示失败。若失败，则游戏无法启动，框架会释放已加载的资源、销毁房间等。

在初始化回调中，你可以执行加载资源（图片、音频等）、创建房间、注册组件类型等操作，这些内容在文档后续的章节中会介绍。

> 你不能在启动游戏之前（执行 `config.on_start` 回调之前）加载资源，因为这些操作依赖 k_game 游戏环境，而此时环境尚未初始化。
> 你可以在游戏运行过程中动态加载资源，但 k_game 推荐你在游戏初始化阶段就尽可能地完成资源加载。
> 原因很简单，k_game 是一个小框架，而你的游戏通常不会涉及太多资源，在初始化阶段一次性加载完所有资源是最合适的。
> 创建房间、注册组件类型等操作同理，也都建议在游戏初始化阶段完成。

