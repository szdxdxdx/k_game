# 事件回调

“事件”一词，实质上表示的是触发回调的时机或条件，即什么时候触发回调，或在什么情况下触发回调。
与游戏帧循环相关的事件共有五类：步开始（begin_step）、计时器（alarm）、步（step）、步结束（end_step）和绘制（draw），
它们在每帧中的执行顺序就是上述介绍的顺序。其中，前四类事件主要用于更新游戏逻辑，最后一类事件则用于渲染游戏画面。
此外还有一些其他的事件回调，如：进入、离开房间事件，对象销毁事件等。

事件回调并非独立存在，而是挂载于房间、对象、组件或组件管理器的实例之上。这些实例是回调的上下文载体（或称宿主）。
触发回调时，它们将被作为参数传入回调。当宿主实例被销毁时，与之关联的回调一并自动解绑并销毁。

## 添加事件回调

添加事件回调使用 `k_XXX_add_YYY_callback()` 系列的函数，XXX 表示回调的宿主，YYY 表示回调的时机。
所有添加回调的操作均返回 `k_callback *` 指针。
例如，给房间添加一个步事件回调，则是 `k_room_add_step_callback()`，给对象添加一个计时器回调，则是 `k_object_add_alarm_callback()`

删除回调只有 `k_callback_del()` 这一个 API。销毁房间、对象、组件、组件管理器时，其挂载的事件回调也会被一并移除，无需手动移除。

## 回调的延迟挂载

如果游戏帧循环相关的回调（步、绘制等），在当前帧中添加的回调会在下一帧之后才生效。删除回调则是立刻失效，若当前帧内它尚未被执行，则不会再执行。

> 回调的延迟挂载，是考虑到这么一种情况：以《飞机大战》为例，飞机和子弹都可以移动，移动逻辑都分别写在它们的步事件中。
> 飞机可以发射子弹，即飞机对象可以在它的步事件中创建子弹对象。子弹可以摧毁飞机，即子弹对象可以在它的步事件中销毁飞机对象。
> 而事件回调的生命周期与其依附的对象绑定。创建对象时，回调被添加入管理器，销毁对象时，回调也跟着被移除。
> 这样一来就会出现：在遍历执行执行回调的过程中，即有新回调加入，又有旧回调被移除。本质是：一边遍历容器一边增删元素。
> 然而，大多数容器不建议也不支持在迭代过程中随意插入或删除元素，因为这很可能导致迭代器失效。
> 因此，对于每一类型的事件回调，k_game 会使用两个容器来管理它们，分别是“预备容器”和“正式容器”。
> 在遍历其中一个容器时，用另一个容器暂存新元素或记录待删除的元素。
> “正式容器”用来存储每帧真正要执行的回调，而“预备容器”则是为了实现回调的延迟挂载和移除。

## 步事件

步开始事件、步事件和步结束事件，亦可统一简称为“步事件”。因为它们的底层逻辑完全相同，只是执行时机不同，用途也不同：
- 步开始事件回调，用于初始化各实例自身在当前帧的状态，或清除上一帧的临时状态。例如：UI 元素记录自身是否被点击，全局 AI 感知判断等。
- 步事件回调，用于实例间交流和更新自身状态，例如：查询按键状态并移动玩家，对象间碰撞检测。此时房间、对象、组件之间可以相互访问数据。
- 步结束事件回调，用于实例修正自身状态，并为绘制做准备，例如：若该实例的某个状态 在 step 阶段被多次修改，则可在此时做确认或修正。

步事件回调每帧一次，而回调之间不强调执行顺序（不论回调是来自房间、对象还是组件，是早添加的还是晚添加的），步开始事件和步结束事件也一样。

> “步事件”的设计灵感来自GameMaker游戏引擎。在GameMaker中，“步”指的是游戏循环中的一帧，代表游戏游戏状态随着每帧逐步更新。
> 步事件的概念在其他游戏引擎中有不同的称呼，例如在 Unity 中，若希望 `GameObject` 实例能每帧执行一定的逻辑，
> 则可以让它继承 `MonoBehaviour` 类并实现 `Update()` 方法，该方法会在每一帧被调用。
> 游戏编程中，很多核心概念在不同引擎中存在不同的名称，而本框架中许多游戏元素选择采用GameMaker风格的命名（如“房间”、“步事件”等），
> 仅是因为GameMaker是我接触的第一款游戏引擎，是出于个人情感上的选择。
 
## 绘制事件

绘制事件与步事件类似，都是在每一帧执行一次，但它们的职责不同。绘制事件有着明确且单一的目的，即渲染画面。
虽然框架不限制开发者在绘制事件回调中与绘制无关的代码，但这不是绘制事件的设计初衷。绘制事件应保持存粹，仅用来执行绘制相关的操作。

本框架中，有一张全局唯一的画布，游戏中一切的画面渲染操作都是围绕这张画布进行的。框架提供了一系列绘制相关的函数，用于在画布上绘制几何图形、图片和文字等。
理论上可以在任意时机调用这些函数，但在绘制事件期间调用，才会真正将绘制的结果渲染到屏幕上。

画布只有一张，每次往画布上绘制新内容都是叠加覆盖已有的内容，绘制的顺序决定了图形在画布中的前后遮挡关系，而绘制事件则实现了类似图层的效果。
添加绘制事件回调时，需要指定绘制的深度组 `z_group` 和深度层 `z_layer`。这两个参数合起来称作绘制深度。深度靠前的元素将遮挡深度靠后的元素。
深度组 `z_group` 越大的元素则深度越靠前，`z_group` 相同时 `z_layer` 越大的元素则深度越靠前，若 `z_layer` 也相同，则它们的遮挡关系是不确定的。
