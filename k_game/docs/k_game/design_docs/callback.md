
k_callback 模块是用于管理游戏中的【回调】，公布的头文件的路径为 `k_game/core/k_callback.h`。

【房间】、【对象】、【组件】 和【组件管理器】是 k_game 中的主要【元素】，它们在各自的生命周期内要执行不同的操作。
k_game 的实现方式是，把各【元素】要在每个游戏帧内执行的操作封装成回调函数，交给 k_game 框架中的【回调管理器】来管理。
【回调管理器】把【回调】按【上下文】和【时机】两种角度进行划分。【上下文】指的就是【元素】，分为【房间】、【对象】、【组件】和【组件管理器】四种。
【时机】则分为【步开始】、【计时】、【步】、【步结束】和【绘制】五种，分别对应一个游戏帧内的五个不同的阶段。

统一使用 `k_XXX_add_YYY_callback()` 系列的函数往【回调管理器】中注册回调，其中 XXX 为【上下文】，YYY 为【时机】。
若单看函数名，你可能感觉不到有【回调管理器】的影子。要是把名字设计成 `k_callback_manager_add_XXX_YYY_callback()`，
确实可以表达「【回调】在 k_game 中是被【回调管理器】管理的」，但是使用 `k_XXX_add_YYY_callback()` 的命名方式，
能表达出我更希望表达的「【回调】是【元素】的一部分，【回调】的存在依赖于【元素】，当【元素】被销毁时，其携带的【回调】也顺带被销毁」。
所以，我不说「注册一个 XXX YYY 回调」，而是说「给 XXX 添加（或挂载）一个 YYY 回调」，
就和 `k_object_add_component()` 想表达的「给【对象】添加（或挂载）一个【组件】」意思一样。

添加回调成功后，函数返回 `k_callback` 的指针。对于【回调】而言只有【增】【删】两种操作，没有 `get`、`set` 或其他任何操作。
你似乎没办法通过这跟指针得知该回调的【上下文】和【时机】？但回调是你手动添加的呀，往什么【元素】上挂载了什么【时机】的回调，你自己还不知道吗？
k_game 内部肯定是能分得清的，但你自己也应该能分得清，k_game 没必要为你提供相关的 `get` 操作。
而 `set` 也没必要，各类型的回调其实也没什么属性能供你设置或修改的，而你要是真想改，你可以删掉旧的，再添加新的。

原本的设计是，我把【回调】按【上下文】分为 `k_room_callback`、`k_object_callback` 等四种，每种都有各自的删除函数。
但后来我认为，既然【回调】只有【增】【删】两种操作，而【删】，要么是【元素】被销毁有 k_game 自动删，要么是手动删。
如果是手动删，你删的时候是压根不关心它是什么【元素】的回调，也不关心是什么【时机】的回调，对吧？
所以后来我把各种类型的回调统一成 `k_callback` 一种，移除回调统一使用 `k_callback_del()` 函数。

【😋】

【对象】和【组件】的回调入参为它们本身，而【房间】和【组件管理器】的回调入参则是一个 `void *` 指针。
这是因为，【对象】和【组件】在房间中有众多实例，需要通过回调的入参来区分它们到底是哪一个实例，
而【房间】指的就是【当前房间】这个实例，【组件管理器】在当前房间中唯一的，k_game 有提供函数访问【当前房间】和它挂载的【组件管理器】，
所以不需要通过回调的入参来指定【房间】和【组件管理器】，取而代之的是更灵活的 `void *` 类型的入参，你可以给回调绑定任意数据。
你可以把【房间】和【组件管理器】的回调入参的 `void *` 指针指向它们自己，这样用法上就跟【对象】和【组件】的回调一样了。

我不希望【对象】和【组件】的每个回调都各自关联一份独立的数据。试想一下，若允许，这份关联数据可以由 `void *` 传入，用起来似乎很方便？
但这份数据的内存谁来管理，怎么释放？在删除回调的时候由你释放吗？那你是不是还要多传一个回调，专门用来释放这份内存？如果是由 k_game 来释放，
那么是不是应该「谁申请，谁释放」？如果是 k_game 来申请内存，你是不是还要多传一个参数来指明申请多大的内存？内存申请到了，但什么时候初始化呢？
你是不是还要多传一个函数，专门用来初始化内存？这一切都太麻烦了。你应该把【对象】和【组件】在回调要用到的数据放进它们的【关联数据】中，
在回调中通过 `k_object_get_data()` 和 `k_component_get_data()` 来获取，所以对于它们的回调，我不提供 `void *` 类型的入参。
