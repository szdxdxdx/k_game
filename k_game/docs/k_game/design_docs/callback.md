
k_callback 模块是用于管理游戏中的回调，公布的头文件的路径为 `k_game/core/k_callback.h`。

房间、对象、组件 和组件管理器是 k_game 中的主要元素，它们在各自的生命周期内要执行不同的操作。
k_game 的实现方式是，把各元素要在每个游戏帧内执行的操作封装成回调函数，交给 k_game 框架中的回调管理器来管理。
回调管理器把回调按上下文和时机两种角度进行划分。上下文指的就是元素，分为房间、对象、组件和组件管理器四种。
时机则分为步开始、计时、步、步结束和绘制五种，分别对应一个游戏帧内的五个不同的阶段。

统一使用 `k_XXX_add_YYY_callback()` 系列的函数往回调管理器中注册回调，其中 XXX 为上下文，YYY 为时机。
若单看函数名，你可能感觉不到有回调管理器的影子。要是把名字设计成 `k_callback_manager_add_XXX_YYY_callback()`，
确实可以表达“回调在 k_game 中是被回调管理器管理的”，但是使用 `k_XXX_add_YYY_callback()` 的命名方式，
能表达出我更希望表达的“回调是元素的一部分，回调的存在依赖于元素，当元素被销毁时，其携带的回调也顺带被销毁”。
所以，我不说“注册一个 XXX YYY 回调”，而是说“给 XXX 添加（或挂载）一个 YYY 回调”，
就和 `k_object_add_component()` 想表达的“给对象添加（或挂载）一个组件”意思一样。

添加回调成功后，函数返回 `k_callback` 的指针。对于回调而言只有增删两种操作，没有 `get`、`set` 或其他任何操作。
你似乎没办法通过这跟指针得知该回调的上下文和时机？但回调是你手动添加的呀，往什么元素上挂载了什么时机的回调，你自己还不知道吗？
k_game 内部肯定是能分得清的，但你自己也应该能分得清，k_game 没必要为你提供相关的 `get` 操作。
而 `set` 也没必要，各类型的回调其实也没什么属性能供你设置或修改的，而你要是真想改，你可以删掉旧的，再添加新的。

原本的设计是，我把回调按上下文分为 `k_room_callback`、`k_object_callback` 等四种，每种都有各自的删除函数。
但后来我认为，既然回调只有增删两种操作，而删，要么是元素被销毁有 k_game 自动删，要么是手动删。
如果是手动删，你删的时候是压根不关心它是什么元素的回调，也不关心是什么时机的回调，对吧？
所以后来我把各种类型的回调统一成 `k_callback` 一种，移除回调统一使用 `k_callback_del()` 函数。

😋

对象和组件的回调入参为它们本身，而房间和组件管理器的回调入参则是一个 `void *` 指针。
这是因为，对象和组件在房间中有众多实例，需要通过回调的入参来区分它们到底是哪一个实例，
而房间指的就是当前房间这个实例，组件管理器在当前房间中唯一的，k_game 有提供函数访问当前房间和它挂载的组件管理器，
所以不需要通过回调的入参来指定房间和组件管理器，取而代之的是更灵活的 `void *` 类型的入参，你可以给回调绑定任意数据。
你可以把房间和组件管理器的回调入参的 `void *` 指针指向它们自己，这样用法上就跟对象和组件的回调一样了。

我不希望对象和组件的每个回调都各自关联一份独立的数据。试想一下，若允许，这份关联数据可以由 `void *` 传入，用起来似乎很方便？
但这份数据的内存谁来管理，怎么释放？在删除回调的时候由你释放吗？那你是不是还要多传一个回调，专门用来释放这份内存？如果是由 k_game 来释放，
那么是不是应该“谁申请，谁释放”？如果是 k_game 来申请内存，你是不是还要多传一个参数来指明申请多大的内存？内存申请到了，但什么时候初始化呢？
你是不是还要多传一个函数，专门用来初始化内存？这一切都太麻烦了。你应该把对象和组件在回调要用到的数据放进它们的关联数据中，
在回调中通过 `k_object_get_data()` 和 `k_component_get_data()` 来获取，所以对于它们的回调，我不提供 `void *` 类型的入参。
