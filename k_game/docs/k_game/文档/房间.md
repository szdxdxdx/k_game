
# 房间

房间相关的绝大部分 API 都声明在 `k_game/core/k_room.h` 头文件中。

## 创建房间

房间是游戏运行的场所。至少创建一个房间，并进入该房间，才能运行游戏。创建房间使用函数 `k_room_create()`，示例代码如下：

```C
/* 此代码不是完整的示例代码，不能直接运行 */

/* 先定义房间携带的自定义数据结构体 */
struct my_room {
    int data;
};

static int on_game_start(void) {
    /* 在游戏的初始化回调中创建房间 */

    /* 编写房间相关的配置，K_ROOM_CONFIG_INIT 为默认值 */
    struct k_room_config config = K_ROOM_CONFIG_INIT;
    config.room_w     = 640;  /* 房间的宽高，表示游戏世界的大小 */
    config.room_h     = 480;
    config.data_size  = sizeof(struct my_room); /* 指定房间携带的关联数据 */
    config.on_create  = my_room_on_create; /* 创建房间时执行的回调 */
    config.on_enter   = my_room_on_enter;  /* 进入房间时执行的回调 */
    
    const char *param = "hello";
    
    struct k_room *room = k_room_create(&config, param); /* 创建房间 */

    k_room_nav_goto(room); /* 进入房间 */
    return 0;
}

/* 创建房间时执行的回调，用作房间初始化 */
static int my_room_on_create(void *param) {

    /* param 是 k_room_create() 传入的参数。在上述代码中，param 传入了一个字符串字面量 */
    printf("create my_room. param='%s'\n", (const char *)param);
    
    /* 初始化房间的自定义关联数据 */
    struct my_room *my_room = k_room_get_data();
    my_room->data = 100;

    return 0;
}

/* 进入房间时执行的回调 */
static void my_room_on_enter(void) {
    
    printf("enter my_room\n");

    struct my_room *my_room = k_room_get_data();
    printf("my_room.data=%d\n", my_room->data);
}
```

创建房间时，需指定自定义数据的结构体大小（上述示例代码中是 `my_room`），k_game 会分配该数据的内存。
用户可在房间的 `on_create()` 回调中对这块内存进行初始化，以及执行其他初始化工作，例如：往房间中放置游戏对象、添加事件回调等。
若 `on_create()` 返回 0，框架会继续完成后续的房间初始化流程，最终成功创建房间。若返回非 0，框架会自动销毁房间。
通过这种方式，用户可以根据不同类型的关卡或场景定制化每个房间，且只用关注初始化过程中业务相关的部分。

> 房间结构本身包含了大量字段，且涉及诸多框架内部细节，所以框架不公开 `k_room` 结构体的定义。
> 为了使房间具备一定的扩展能力，本框架采用一种在 C 语言中的很常见、很典型的封装技巧：使用 `void*` 指针挂载用户自定义数据。
> 本框架的所有核心结构体（如房间、对象、组件等）都采用这种设计方式。

由于房间肩负太多职责，所以太灵活地操作房间是一件很危险的事。出于对框架稳定性和使用安全性的考量，本框架暂不提供销毁房间的 API。
因为一旦房间被不当销毁，资源可能被错误释放，造成悬空指针等一系列问题。目前只能在游戏结束时，由框架集中销毁所有房间。
销毁房间时，房间中的对象、组件等资源会被一并销毁，用户可在房间的 `on_destroy()` 回调中完成对其他资源的清理工作。

## 进入房间

在游戏的初始化阶段，你可以创建多个房间，之后必须从中指定一个初始房间，进入该房间后，游戏才正式开始。
你可以使用 `k_room_nav_goto()` 来指定要进入的房间。调用该函数不会立即触发房间切换，而是将切换请求记录下来，等到合适的时机再执行。
具体来说：若你在初始化阶段指定要进入的初始房间，k_game 会在初始化回调函数返回 0 之后，再进入该房间；
若你在游戏运行过程中切换房间，则会等到当前游戏帧结束之后再执行切换操作。

k_game 使用类似页面栈来管理房间的切换。初始时房间栈为空，在游戏的初始化回调中指定初始房间后，将该房间压入栈。
用 `k_room_nav_push()` 的方式进入房间，表示将一个新房间压入房间栈顶，而原有的房间依然保留在栈中。
用 `k_room_nav_goto()` 的方式进入房间，则表示直接用新房间替换当前运行的房间。
同一时间只能有一个房间正在运行。处于栈顶的房间即为当前正在运行的房间。
`k_room_nav_pop()` 则是弹出栈顶房间，回到上一个房间继续运行，若房间栈已空则结束游戏。

> 若未来 k_game 要提供允许用户主动销毁房间的 API，需慎重考虑要如何处理“销毁仍处于栈中的房间”的这一特殊情况。
> 销毁操作通常是不会执行失败的。若房间因仍处栈中而销毁失败，迫使用户尝试二次销毁，API 会变得很繁琐难用。
> 若销毁成功，那么在后续弹栈回退房间时，绝对不能访问已销毁的房间，但若跳过它继续回退，栈的操作就会变得不一致，回退逻辑复杂。
> 此情况是本框架目前尚未公布主动销毁房间 API 的原因之一。

## 当前房间

房间作为游戏的运行场所，具有很长的生命周期。框架内部始终记录当前正在运行的房间。

框架所提供的操作房间的 API，默认操作的是当前运行中的房间，这些 API 的命名都比较简洁，例如：`k_room_get_data()` 用于获取当前房间的用户自定义数据。
若要操作指定房间，API 通常以“_of”、“_from” 等后缀结尾，例如：`k_room_get_data_of()`。

房间一旦被创建则常驻内存。退出当前房间时，房间被移出栈，但并没有被销毁。
房间之间的数据交流，最简单直接的方式是通过指针获取对方的用户自定义数据，而房间指针长期有效，即使房间不在栈中也可以访问其数据。
