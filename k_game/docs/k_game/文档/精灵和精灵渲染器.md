
# 精灵、精灵渲染器

## 精灵

精灵相关的 API 都声明在 `k_game/core/k_sprite.h` 头文件中。

精灵用作游戏对象的外观表现，它属于图片资源。精灵可以是一张图片，也可以是一组动画序列帧。

加载精灵的示例代码：
```C
/* 加载精灵素材（建议在初始化游戏时执行调用本函数） */
static void yx_load_sprite(void) {
    struct k_image *img = k_image_load("xxx.png"); /* 加载原素材图片 */

    struct k_sprite_frame_config frames[6]; /* 假设该精灵一共有 6 帧 */
    int i = 0;
    for (; i < 6; i++) {
        frames[i].offset_x = i * 64; /* 定义每个精灵帧在精灵表中的偏移 */
        frames[i].offset_y = 64;
        frames[i].image = img;
        frames[i].delay = 100; /* 播放时每帧延时 100 毫秒 */
    }

    struct k_sprite_config sprite_config;
    sprite_config.sprite_w = 64; /* 精灵的宽高尺寸是 64x64，中心点设在 32x32 */
    sprite_config.sprite_h = 64;
    
    /* 用作渲染精灵时的位置锚点 */
    sprite_config.origin_x = 32;
    sprite_config.origin_y = 32;
    sprite_config.frames = frames;
    sprite_config.frames_num = 6;

    spr = k_sprite_create(&sprite_config); /* 创建精灵 */
}
```

示例代码中，手动创建精灵的方式存在硬编码问题。在编码时明确指定精灵的帧数、尺寸等信息，一旦精灵素材发生变更，则需要修改代码并重新编译程序。
在实际的游戏开发中，精灵素材通常是读取配置文件来批量导入。若素材有改动，也只用同步修改外部的配置文件，不需要改动代码。

框架提供的示例 demo 中定义有 `yx_sprite_load_from_sheet()` 函数，用于加载 aseprit 软件导出的精灵素材。

> aseprite是一款绘图软件，适合用于开发像素游戏的精灵素材。该软件支持将精灵动画导出为 png 格式精灵表，
> 同时生成一份用于描述精灵表中各精灵的位置、尺寸、动画时长等信息的 json 文件。

该函数没有集成在框架内部，是因为不同软件生成的精灵素材配置文件存在差异，本框架不打算对特定软件的配置文件格式进行硬性支持。
你可以参考该函数的实现，并根据实际需求来编写适配自己项目的加载精灵素材的函数。

## 精灵渲染器

精灵渲染器相关的 API 都声明在 `k_game/ext/k_sprite_renderer.h` 头文件中。

一般来说，游戏对象会关联一个精灵作为其外观表现。不推荐你直接使用画布模块提供的 API 来手动绘制精灵，因为该 API 只能绘制某个精灵帧。
而一个精灵往往是一组动画序列。如果要用画布的API手动绘制精灵动画，需要开发者自行维护计时器、当前帧索引等相关状态变量。

精灵渲染器组件（或称“动画机”）是框架的内建组件。它封装了上述手动操控绘制精灵动画的流程，在其内部维护一个计时器和当前帧索引，
并注册有一个绘制事件回调，用于绘制精灵动画。给对象挂载一个精灵渲染器组件，并且指定关联的精灵，由渲染器负责绘制。示例代码：
```C
struct k_sprite_renderer_config spr_rdr; /* <- 精灵渲染器的配置 */
spr_rdr.x       = &player->x; /* 指定渲染器关联的坐标 */
spr_rdr.y       = &player->y;
spr_rdr.sprite  = spr; /* 指定使用的精灵资源 */
spr_rdr.z_group = 0; /* 指定绘图深度为(0, 2) */
spr_rdr.z_layer = 2;
k_object_add_sprite_renderer(object, &spr_rdr); /* 给玩家对象添加精灵渲染器组件 */
```

精灵渲染器通过一对指针关联一个外部坐标。精灵渲染器需要将精灵绘制什么坐标位置，不是由渲染器自己决定的，而是由这个外部坐标决定的。
一般来说，自定义游戏对象的属性中都会有一对坐标。给该对象添加精灵渲染器组件时，把这对坐标的指针也交给渲染器。
这样一来，在每帧更新时，由对象自身负责更新这个坐标，而精灵渲染器则根据指针读取坐标值，并在该位置绘制精灵。
若对象不会移动，则它的属性字段中可能没有坐标，那么可以让精灵渲染器绑定静态内存段的坐标。

> 本框架中的其他内建组件也都是指针来关联外部坐标。
> 
> 若该坐标是自定义对象的属性字段，那对于精灵渲染器而言，这对指针是始终有效的。
> 这是因为，在销毁对象时，精灵渲染器作为该对象挂载的组件会早于该对象先被销毁，所以不会出现悬空指针问题。
