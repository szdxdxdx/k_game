
# 事件回调

事件回调相关的绝大部分 API 都声明在 `k_game/core/k_callback.h` 头文件中。

## 概念介绍

> 框架之所以称为“框架”，正是因为它预先定义好了程序的主要运行流程，开发者只需根据这一流程填充具体的逻辑即可。
> 在 C 语言中，常用的实现方式是通过函数指针和回调机制。框架在程序生命周期中始终掌握主导权，用户编写的代码听从框架的调度。
> 
> “框架”与“库函数”都是别人提供代码你来使用，两者区别在于：使用库时，你决定程序的流程，你在需要时主动去调用库函数；
> 使用框架时，你不再控制程序的主流程，而是写一些“回调”逻辑，等着框架在适当的时候来调用你写的代码。

本框架将一个游戏过程划分为多个阶段，每个阶段都有相应的事件类型，开发者可以针对不同事件注册相应的回调函数，用于实现具体的游戏逻辑。
“事件”一词，实质上表示的是触发回调的时机或条件，即什么时候触发回调，或在什么情况下触发回调。

事件回调并非独立存在，而是挂载于房间、对象、组件或组件管理器的实例之上。这些实例是回调的上下文载体（或称宿主）。
当宿主实例被销毁时，与之关联的回调一并自动解绑并销毁。

与游戏循环相关的事件共有五类：步开始（begin_step）、计时器（alarm）、步（step）、步结束（end_step）和绘制（draw），
它们在每帧中的执行顺序就是上述介绍的顺序。其中，前四类事件主要用于更新游戏逻辑，最后一类事件则用于渲染游戏画面。

此外还有一些其他的与游戏循环无关的事件回调，如：进入、离开房间事件，对象销毁事件等，这里不再过多介绍。

### 步事件

步开始事件、步事件和步结束事件，亦可统一简称为“步事件”。因为它们的底层逻辑完全相同，只是执行时机不同，用途也不同：
- 步开始事件回调，用于初始化各实例自身在当前帧的状态，或清除上一帧的临时状态。例如：UI 元素记录自身是否被点击，全局 AI 感知判断等。
- 步事件回调，用于实例间交流和更新自身状态，例如：查询按键状态并移动玩家，对象间碰撞检测。此时房间、对象、组件之间可以相互访问数据。
- 步结束事件回调，用于实例修正自身状态，并为绘制做准备，例如：若该实例的某个状态 在 step 阶段被多次修改，则可在此时做确认或修正。

步事件回调每帧一次，而回调之间不强调执行顺序（不论回调是来自房间、对象还是组件，是早添加的还是晚添加的），步开始事件和步结束事件也一样。

> “步事件”的设计灵感来自GameMaker游戏引擎。在GameMaker中，“步”指的是游戏循环中的一帧，代表游戏游戏状态随着每帧逐步更新。
> 步事件的概念在其他游戏引擎中有不同的称呼，例如在 Unity 中，若希望 `GameObject` 实例能每帧执行一定的逻辑，
> 则可以让它继承 `MonoBehaviour` 类并实现 `Update()` 方法，该方法会在每一帧被调用。
> 游戏编程中，很多核心概念在不同引擎中存在不同的名称，而本框架中许多游戏元素选择采用GameMaker风格的命名（如“房间”、“步事件”等），
> 仅是因为GameMaker是我接触的第一款游戏引擎，是出于个人情感上的选择。

### 计时器事件

计时器事件回调是在倒计时结束时执行的回调。每个计时器回调最多只能被触发一次，回调被触发执行后就被移除（框架会主动删除，无需手动删除）。

> 与“步事件”相比，“计时器事件”更像是一个“事件”。触发回调时，会给人一种“倒计时结束这件事发生了”的感觉。而步事件则更像是对一个游戏帧不同阶段的划分。
> 前文提过，本框架中不少游戏元素的命名借鉴了 GameMaker 游戏引擎。GameMaker 确实内置有许多事件，例如按键按下事件、对象碰撞事件，甚至是对象生命值耗尽事件。
> 开发者可以在图形化界面中拖拽事件的图标按钮，像搭积木一样组织游戏逻辑，亦可在脚本代码中通过调用 API 的方式代替或模拟大部分其他事件。
> 比如，在 GameMaker 中若想实现按下某个键后执行某段逻辑，可以采用注册按键事件的方式被动响应，也可以在脚本中调用按键检测 API 后主动执行。
> 而本框架有意设计和实现更多类型的事件回调，但这些事件应是不可替代的，不能被步事件轻易模拟的事件。

### 绘制事件

绘制事件与步事件类似，都是在每一帧执行一次，但它们的职责不同。绘制事件有着明确且单一的目的，即渲染画面。
虽然框架不限制开发者在绘制事件回调中与绘制无关的代码，但这不是绘制事件的设计初衷。绘制事件应保持存粹，仅用来执行绘制相关的操作。

本框架中，有一张全局唯一的画布，游戏中一切的画面渲染操作都是围绕这张画布进行的。框架提供了一系列绘制相关的函数，用于在画布上绘制几何图形、图片和文字等。
理论上可以在任意时机调用这些函数，但在绘制事件期间调用，才会真正将绘制的结果渲染到屏幕上。

画布只有一张，每次往画布上绘制新内容都是叠加覆盖已有的内容，绘制的顺序决定了图形在画布中的前后遮挡关系，而绘制事件则实现了类似图层的效果。
添加绘制事件回调时，需要指定绘制的深度组 `z_group` 和深度层 `z_layer`。这两个参数合起来称作绘制深度。深度靠前的元素将遮挡深度靠后的元素。
深度组 `z_group` 越大的元素则深度越靠前，`z_group` 相同时 `z_layer` 越大的元素则深度越靠前，若 `z_layer` 也相同，则它们的遮挡关系是不确定的。

## 添加事件回调

添加事件回调使用 `k_XXX_add_YYY_callback()` 系列的函数，XXX 表示回调的宿主，YYY 表示回调的时机。所有添加操作均返回 `k_callback *` 指针。
例如，给房间添加一个步事件回调，则是 `k_room_add_step_callback()`，给对象添加一个计时器回调，则是 `k_object_add_alarm_callback()`

示例：
```C
/* 此代码不是完整的示例代码，不能直接运行 */

/* 房间的步事件回调，每帧都会触发一次 */
static void my_room_on_step(void *data) {
    printf("%s\n", (const char *)data);
}

/* 在创建房间时，给房间添加回调 */
static int my_room_on_create(void *param) {
    const char *data = "step_callback";
    k_room_add_step_callback(data, my_room_on_step);
    return 0;
}
```

> 事件回调可以按事件类型分类（步事件回调、绘制事件回调等），也可以按上下文分类（房间回调、对象回调等）。
> 实际上，回调在框架内部是通过“回调管理器”（步事件回调管理器、绘制事件回调管理器等）管理的，
> 但看添加回调的函数名 `k_XXX_add_YYY_callback()`，你可能感觉不到有“回调管理器”的存在，反而可能觉得回调是由房间、对象的实例来管理的。
> 之所以不把函数名字设计成 `k_callback_manager_add_XXX_YYY_callback()`，而是使用 `k_XXX_add_YYY_callback()` 的命名方式，
> 是因为我更希望表达的“回调是元素的一部分，回调的存在依赖于元素，当元素被销毁时，其携带的回调也顺带被销毁”。
> 我在“忠实反映实现方式”和“强调设计理念”之间做了权衡，选择了后者。
> 所以，我不说“注册一个 XXX YYY 回调”，而是说“给 XXX 添加（或挂载）一个 YYY 回调”。

### 回调的入参

房间的事件回调的入参是一个 `void *` 指针，可以用来绑定一个自定义外部数据。

组件管理器的回调入参也是一个 `void *` 指针。而对象或组件的事件回调入参为该对象和组件示例本身的指针。

> 对象和组件在房间中有众多实例，所以需要通过回调的入参来区分它们到底是哪一个实例。
> 而房间指的就是当前房间这个实例，组件管理器在当前房间中唯一的，k_game 有提供函数访问当前房间和它挂载的组件管理器，
> 所以不需要通过回调的入参来指定房间和组件管理器，取而代之的是更灵活的 `void *` 类型的入参，你可以给回调绑定任意数据。
> 你可以把房间和组件管理器的回调入参的 `void *` 指针指向它们自己，这样用法上就跟对象和组件的回调一样了。
> 
> 我不希望对象和组件的每个回调都各自关联一份独立的数据。试想一下，若允许，这份关联数据可以由 `void *` 传入，用起来似乎很方便？
> 但这份数据的内存谁来管理，怎么释放？在删除回调的时候由你释放吗？那你是不是还要多传一个回调，专门用来释放这份内存？如果是由 k_game 来释放，
> 那么是不是应该“谁申请，谁释放”？如果是框架来申请内存，你是不是还要多传一个参数来指明申请多大的内存？内存申请到了，但什么时候初始化呢？
> 你是不是还要多传一个函数，专门用来初始化内存？这一切都太麻烦了。你应该把对象和组件在回调要用到的数据放进它们的关联数据中，
> 在回调中通过 `k_object_get_data()` 和 `k_component_get_data()` 来获取，所以对于它们的回调，我不提供 `void *` 类型的入参。

### 回调的返回值

事件回调函数的返回值统一是 `void`。

> 事件回调函数返回 `void`，并非框架要求函数一定执行成功，而是框架只负责通知你这个事件发生了，至于函数做何处理、处理是否成功，框架不干涉。
> 例如，假设你的事件回调中需要创建一个游戏对象，但因某些条件未达到导致对象创建失败，你应该自行通过标志位或其他状态变量来延迟重试或切换失败逻辑，
> 而不是指望通过函数返回值让框架帮你处理。
> 
> 游戏初始化时执行的回调 `on_start()`，和创建房间时执行的回调 `on_create()`，都通过返回 `int` 类型的状态码来表达函数是否执行成功，
> 框架会检查返回值，在函数失败时执行回滚操作。

### 回调生效的时机

关于游戏循环相关的回调（步、绘制等），如果当前尚未执行到“步”阶段（例如当前处于“步开始”阶段），新添加的“步事件”回调会在当前帧中之后的“步”阶段执行；
当前已经执行到“步”阶段，新添加的“步事件”回调会在下一帧才执行。

## 删除事件回调

删除回调只有 `k_callback_del()` 这一个 API。销毁房间、对象、组件、组件管理器时，其挂载的事件回调也会被一并移除，无需手动移除。

> 对于回调，框架只提供有 `add` 和 `del` 两种操作，没有 `get`、`set` 或其他任何操作。
> 添加回调成功后，函数返回 `k_callback *` 指针。你似乎没办法通过这跟指针得知该回调的类型？
> 但回调是你手动添加的呀，往什么元素上挂载了什么时机的回调，你自己还不知道吗？
> 框架内部肯定是能分得清的，但你自己也应该能分得清，框架没必要为你提供相关的 `get` 操作。
> 而 `set` 也没必要，各类型的回调其实也没什么属性能供你设置或修改的，而你要是真想改，你可以删掉旧的，再添加新的。
